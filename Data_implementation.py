"""
Author: Karen Alley, Brent Butler, Melissa Cushing
Date: Spring 2013
Purpose: This script accomplishes most of our GIS3 project on assessing the
vulnerability of surface-melt-induced collapse.  It takes two prepared input 
files - one tiff of averaged melt days data, and one tiff of averaged 
backscatter data, and ensures that their extents and resolutions are the same.
Then the raster files are clipped to the extent of ice shelf shapefiles, all
provided in the same folder.  The melt days and backscatter data withn the ice 
shelf extents are plotted in two ways: pixel by pixel, and by the average
values of the shelf.  Finally, the melt days raster is reclassified based on
pre-determined intervals to reflect a vulnerability index based on the melt 
days-backscatter relationship.
"""

'''**************************************************************
Import necessary modules and extensions and set workspace
**************************************************************'''

import os
import numpy as np
import pylab as py
from pylab import *
from osgeo import gdal
import arcpy 
import arcpy.sa as sa
from arcpy import env
arcpy.CheckOutExtension("Spatial")
env.workspace = r'E:\\'
env.overwriteOutput = 1


'''**************************************************************
Specify data input files
**************************************************************'''

meltTheme = 'GIS_Project\\Melt_correct_extent_pixels.tif'
backTheme = 'GIS_Project\\avg_2005_2008.tif'
env.cellSize = 2225
arcpy.env.snapRaster = backTheme
maskFolder = 'E://plot_test_masks//'
reclassFolder = 'E://Reclass//'

'''**************************************************************
Clip the data to ice shelf shapefiles
**************************************************************'''

print "Clipping data"
# Convert input data to raster objects
m = sa.Raster(meltTheme)
b = sa.Raster(backTheme)

# Clip the backscatter and melt days datasets to the ice shelf masks
mask_folder = os.listdir(maskFolder) # List all files in the directory with the shelf masks
shelfShapes = [s for s in mask_folder if s.endswith('.shp')] # Extract all files that end with .shp from the folder

meltRasters = []
backRasters = []
meltArrays = []
backArrays = []
for i in range(len(shelfShapes)):
    arcpy.env.extent = maskFolder + shelfShapes[i]
    melt = sa.ExtractByMask(m,maskFolder+shelfShapes[i]) # Clip the melt to the shelf extent
    back = sa.ExtractByMask(b,maskFolder+shelfShapes[i])  # Clip the backscatter to the shelf extent
    meltStr = str(melt)
    backStr = str(back)    
    meltRast = sa.Raster(meltStr)   # Creates raster objects from the clipped data
    backRast = sa.Raster(backStr)
    meltRasters.append(meltRast)
    backRasters.append(backRast)
    meltNumpy = arcpy.RasterToNumPyArray(meltRast)  # Creates NumPy arrays from the raster objects
    backNumpy = arcpy.RasterToNumPyArray(backRast)
    meltArrays.append(meltNumpy)    # Places the NumPy arrays in lists 
    backArrays.append(backNumpy)
    print 'Processed shelf mask ' + str(i+1)


'''**************************************************************
Plot the data pixel-by-pixel
**************************************************************'''

## Note: We know we could have put these next two sections in the previous loop, 
# and it would have been a bit more efficient.  However, we made the decision
# that flexibility was more important than efficiency in this case - this format
# allows us to easily change things and replot without having to re-run the
# whole script.  Also, given that we will be coming back to this in several 
# months, we thought this would be an easier way to remember how to use the script!
print 'Plotting'
fig1 = py.figure()
for i in range(len(meltArrays)):
    # Extract only the values in the subsets that are within the ice shelf
    # area - that is, exclude the no data values
    meltFlat = meltArrays[i][meltArrays[i] != -3.402823466385288598e+38]
    backFlat = backArrays[i][backArrays[i] != -3.402823466385288598e+38]
    # Plot the arrays against each other, pixel by pixel
    py.plot(meltFlat,backFlat,'o', hold = True)

py.xscale('log')
py.ylabel('Average backscatter 2005-2008')
py.xlabel('Average annual melt days 1979-2012')
py.title('Pixel-by-pixel backscatter vs. melt days')
'''**************************************************************
Plot ice shelf averages
**************************************************************'''
# Again, this loop was constructed separately to make the script as flexible
# as possible when experimenting with aspects of the plots
fig2 = py.figure()
for i in range(len(meltArrays)):
    # Again, extract only the values in the subsets that are within the ice shelf
    # area - that is, exclude the no data values
    meltAvg = meltArrays[i][meltArrays[i] != -3.402823466385288598e+38]
    backAvg = backArrays[i][backArrays[i] != -3.402823466385288598e+38]
    mAv = meltAvg.mean() # Calculate the mean value for each shelf area
    bAv = backAvg.mean()
    # Plot the mean melt days and backscatter values against each other
    p = py.plot(mAv,bAv, 'o', hold = True)

py.xscale('log')   
py.ylabel('Average backscatter 2005-2008')
py.xlabel('Average annual melt days 1979-2012')
py.title('Shelf-average backscatter vs. melt days')
py.show()


'''**************************************************************
Create an example vulnerability index map
**************************************************************'''

'''
Ultimately we will create a more complex algorithm for the vulnerability
index.  For the moment, we will simply reclassify the melt days dataset based
on the trend we have found by plotting averages.  This is an example of how 
the index map will eventually be created (using more complex raster math), 
rather than a true final result. Once again, it is presented separately from
the other for loops so it is easy to change the new class definitions.
'''
print "Creating vulnerability index"

shelfBase = [os.path.splitext(x)[0] for x in shelfShapes]

for i in range(len(meltRasters)):
    arcpy.CalculateStatistics_management(meltRasters[i])
    # Reclassify the raster based on pre-determined class ranges
    outMelt = arcpy.sa.Reclassify(meltRasters[i], 'Value', sa.RemapRange([[0,1,1],[1,1.9,2],[1.9,2.5,3],[2.5,6.9,4],[6.9,15,5],[15,27,6],[27,50,7],[50,150,8]]),'NODATA')
    outMelt.save(reclassFolder + shelfBase[i] + 'r')
    print "Reclassified shelf " + str(i+1)

